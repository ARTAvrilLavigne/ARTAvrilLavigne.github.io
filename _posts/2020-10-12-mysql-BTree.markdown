---
layout:     post
title:      "mysql的索引数据结构"
subtitle:   " \"welcome to ARTAvrilLavigne Blog\""
date:       2020-10-12 21:34:00
author:     "ARTAvrilLavigne"
header-img: "img/post-bg-2015.jpg"
tags:
    - mysql
---
## 一、mysql索引<br>

### 1.1、索引数据结构<br>

　　**MySQL的索引使用B+树作为数据结构，而不是B树。**原因如下所示：<br>
* B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。<br>

* B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。<br>

* B+树更便于遍历：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。<br>

* B+树更适合基于范围的查询：B树在提高了IO性能的同时并没有解决元素遍历的效率低下问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。<br>

## 二、B树<br>

### 2.1、定义<br>

　　B树是平衡的多叉查找树，也就是说最多可以开m个叉（m>=2），我们称之为m阶b树。总的来说，m阶B树满足以下条件：<br>
* 每个节点至多可以拥有m棵子树<br>
* 根节点，只有至少有2个节点（要么极端情况，就是一棵树就一个根节点，单细胞生物，即是根，也是叶，也是树)<br>
* 非根非叶的节点至少有的Ceil(m/2)个子树(Ceil表示向上取整，图中5阶B树，每个节点至少有3个子树，也就是至少有3个叉)<br>
* 非叶节点中的信息包括[n,A0,K1,A1,K2,A2,…,Kn,An]，，其中n表示该节点中保存的关键字个数，K为关键字且Ki<Ki+1，A为指向子树根节点的指针<br>
* 从根到叶子的每一条路径都有相同的长度，也就是说，叶子节在相同的层，并且这些节点不带信息，实际上这些节点就表示找不到指定的值，也就是指向这些节点的指针为空<br>

### 2.2、查询过程<br>

　　B树的查询过程和二叉排序树比较类似，从根节点依次比较每个结点，因为每个节点中的关键字和左右子树都是有序的，所以只要比较节点中的关键字，或者沿着指针就能很快地找到指定的关键字，如果查找失败，则会返回叶子节点，即空指针。<br>
  
![object](https://github.com/ARTAvrilLavigne/ARTAvrilLavigne.github.io/blob/master/myblog/2020-10-12-mysql-BTree/1.png?raw=true)<br>

　　如上图所示，查询图中字母表中的K<br>
1、从根节点P开始，K的位置在P之前，进入左侧指针<br>
2、左子树中，依次比较C、F、J、M，发现K在J和M之间<br>
3、沿着J和M之间的指针，继续访问子树，并依次进行比较，发现第一个关键字K即为指定查找的值<br>

## 三、B+树的定义<br>

　　B+树与B树的差异在于：<br>
* 有n棵子树的节点含有n个关键字（也有认为是n-1个关键字）<br>
* 所有的叶子节点包含了全部的关键字，及指向含这些关键字记录的指针，且叶子节点本身根据关键字自小而大顺序连接<br>
* 非叶子节点可以看成索引部分，节点中仅含有其子树（根节点）中的最大（或最小）关键字<br>

　　B+树的查找过程，与B树类似，只不过查找时如果在非叶子节点上的关键字等于给定值，并不终止，而是继续沿着指针直到叶子节点位置。因此在B+树，不管查找成功与否，每次查找都是走了一条从根到叶子节点的路径。<br>

## 四、B+树和B树的区别<br>

　　B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。<br>
　　B+ 树的优点在于：<br>
* IO次数更少：由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。<br>
* 遍历更加方便：B+树的叶子结点都是相链的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。<br>
　　但是B树也有优点，其优点在于由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。<br>


  



## 参考文献<br>
[1]https://www.jianshu.com/p/7ce804f97967<br>
[2]https://www.jianshu.com/p/9e9aca844c13<br>
[3]https://www.cnblogs.com/xiaoxi/p/6868087.html<br>
