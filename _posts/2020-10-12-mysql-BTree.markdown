---
layout:     post
title:      "mysql的索引数据结构"
subtitle:   " \"welcome to ARTAvrilLavigne Blog\""
date:       2020-10-12 21:34:00
author:     "ARTAvrilLavigne"
header-img: "img/post-bg-2015.jpg"
tags:
    - mysql
---
## 一、mysql索引<br>

### 1.1、索引数据结构<br>

　　**MySQL的索引使用B+树作为数据结构，而不是B树。**原因如下所示：<br>
* B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。<br>

* B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。<br>

* B+树更便于遍历：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。<br>

* B+树更适合基于范围的查询：B树在提高了IO性能的同时并没有解决元素遍历的效率低下问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。<br>

## 二、B树<br>

### 2.1、定义<br>

　　B树是平衡的多叉查找树，也就是说最多可以开m个叉（m>=2），我们称之为m阶b树。总的来说，m阶B树满足以下条件：<br>
* 每个节点至多可以拥有m棵子树<br>
* 根节点，只有至少有2个节点（要么极端情况，就是一棵树就一个根节点，单细胞生物，即是根，也是叶，也是树)<br>
* 非根非叶的节点至少有的Ceil(m/2)个子树(Ceil表示向上取整，图中5阶B树，每个节点至少有3个子树，也就是至少有3个叉)<br>
* 非叶节点中的信息包括[n,A0,K1,A1,K2,A2,…,Kn,An]，，其中n表示该节点中保存的关键字个数，K为关键字且Ki<Ki+1，A为指向子树根节点的指针<br>
* 从根到叶子的每一条路径都有相同的长度，也就是说，叶子节在相同的层，并且这些节点不带信息，实际上这些节点就表示找不到指定的值，也就是指向这些节点的指针为空<br>

### 2.2、查询过程<br>

　　B树的查询过程和二叉排序树比较类似，从根节点依次比较每个结点，因为每个节点中的关键字和左右子树都是有序的，所以只要比较节点中的关键字，或者沿着指针就能很快地找到指定的关键字，如果查找失败，则会返回叶子节点，即空指针。<br>
  
![object](https://github.com/ARTAvrilLavigne/ARTAvrilLavigne.github.io/blob/master/myblog/2020-10-12-mysql-BTree/1.png?raw=true)<br>

　　如上图所示，查询图中字母表中的K<br>
1、从根节点P开始，K的位置在P之前，进入左侧指针<br>
2、左子树中，依次比较C、F、J、M，发现K在J和M之间<br>
3、沿着J和M之间的指针，继续访问子树，并依次进行比较，发现第一个关键字K即为指定查找的值<br>
  

## 三、B+树的定义<br>


  



## 参考文献<br>
[1]https://www.jianshu.com/p/7ce804f97967<br>
[2]https://www.jianshu.com/p/9e9aca844c13<br>
[3]https://www.cnblogs.com/xiaoxi/p/6868087.html<br>
