---
layout:     post
title:      "Spring框架总结"
subtitle:   " \"welcome to ARTAvrilLavigne Blog\""
date:       2017-12-31 19:01:00
author:     "ARTAvrilLavigne"
header-img: "img/post-bg-2015.jpg"
tags:
    - javaee
---  
## 今天课程：Spring框架第一天 ##
	
----------
	
**Spring框架的学习路线**
	
	1. Spring第一天：Spring的IOC容器之XML的方式，Spring框架与Web项目整合
	2. Spring第二天：Spring的IOC容器之注解的方式，Spring的AOP技术
	3. Spring第三天：Spring的事务管理、Spring框架的JDBC模板
	4. Spring第四天：SSH三大框架的整合
	
----------
	
**今天内容概述**
	
	1. Spring框架的概述
	2. SpringIOC的快速入门
	3. IoC容器XML的方式
	4. 在web项目中集成Spring
	
----------
	
### 案例一：使用Spring的IOC技术完成客户的保存功能 ###
	
----------
	
**需求分析**
	
	1. 使用Spring的IOC技术完成客户的保存功能
	
----------
	
### 技术分析之Spring框架的概述和入门 ###
	
----------
	
**技术分析之什么是Spring框架**
	
	1. Spring框架的概述
		* Spring是一个开源框架
		* Spring是于2003 年兴起的一个轻量级的Java开发框架，由Rod Johnson在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。
		* 它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。
		* Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以	从Spring中受益。
		* Spring的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring是一个分层的JavaSE/EEfull-stack(一站式) 轻量级开源框架。
		
		* EE开发分成三层结构
			* WEB层		-- Spring MVC
			* 业务层	-- Bean管理:(IOC)
			* 持久层	-- Spring的JDBC模板.ORM模板用于整合其他的持久层框架
	
----------
	
**技术分析之Spring框架的特点**
	
	1. 为什么要学习Spring的框架
		* 方便解耦，简化开发
			* Spring就是一个大工厂，可以将所有对象创建和依赖关系维护，交给Spring管理
		* AOP编程的支持
			* Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能
		* 声明式事务的支持
			* 只需要通过配置就可以完成对事务的管理，而无需手动编程
		* 方便程序的测试
			* Spring对Junit4支持，可以通过注解方便的测试Spring程序
		* 方便集成各种优秀框架
			* Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts2、Hibernate、MyBatis、Quartz等）的直接支持
		* 降低JavaEE API的使用难度
			* Spring 对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低
	
	2. Spring框架的版本
		* Spring3.x和Spring4.x的版本
	
----------
	
**技术分析之Spring框架的IOC核心功能快速入门**
	
	1. 什么是IOC的功能？
		* IoC		-- Inverse of Control，控制反转，将对象的创建权反转给Spring！！
		* 使用IOC可以解决的程序耦合性高的问题！！
	
![](./图片/01-IOC.bmp)	
	
	2. 步骤一：下载Spring框架的开发包
		* 官网：http://spring.io/
		* 下载地址：http://repo.springsource.org/libs-release-local/org/springframework/spring解压:(Spring目录结构:)
			* docs		-- API和开发规范
			* libs		-- jar包和源码
			* schema	-- 约束
	
	3. 步骤二：创建JavaWEB项目，引入Spring的开发包
		* 引入Spring框架IOC核心功能需要的具体的jar包
			* Spring框架的IOC的功能，那么根据Spring框架的体系结构图能看到，只需要引入如下的jar包
				* Beans
				* Core
				* Context
				* Expression Language
			
			* Spring框架也需要引入日志相关的jar包
				* 在spring-framework-3.0.2.RELEASE-dependencies/org.apache.commons/com.springsource.org.apache.commons.logging/1.1.1
					* com.springsource.org.apache.commons.logging-1.1.1.jar
				
				* 还需要引入log4j的jar包 spring-framework-3.0.2.RELEASE-dependencies\org.apache.log4j\com.springsource.org.apache.log4j\1.2.15
					* com.springsource.org.apache.log4j-1.2.15.jar
	
	4. 步骤三：创建对应的包结构，编写Java的类，要注意：以后使用Spring框架做开发，都需要来编写接口与实现类！！
		* com.itcast.demo1
			* UserService			-- 接口
			* UserServiceImpl		-- 具体的实现类
	
	5. 步骤四：想把UserServiceImpl实现类的创建交给Spring框架来管理，需要创建Spring框架的配置文件，完成配置
		* 在src目录下创建applicationContext.xml的配置文件，名称是可以任意的，但是一般都会使用默认名称！！
		
		* 引入spring的约束，需要先找到具体的约束头信息！！
			* spring-framework-3.2.0.RELEASE\docs\spring-framework-reference\html\xsd-config.html
			* 具体的约束如下：		
				<beans xmlns="http://www.springframework.org/schema/beans"
				    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
				    xsi:schemaLocation="
				        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
				</beans>
		
		* 完成UserService的配置
			<!-- Spring的快速入门 -->
			<bean id="userService" class="com.itcast.demo1.UserServiceImpl"/>
	
	6. 步骤五：编写测试程序，采用Spring框架的工厂方式来获取到UserService接口的具体实现类！！
		public void demo2(){
			// 使用Spring的工厂:
			ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
			// 通过工厂获得类:
			UserService userService = (UserService) applicationContext.getBean("userService");
			userService.sayHello();
		}
	
----------
	
**入门总结之Spring框架中的工厂（了解）**
	
	1. ApplicationContext接口  推荐  
		* 使用ApplicationContext工厂的接口，使用该接口可以获取到具体的Bean对象
		* 该接口下有两个具体的实现类
			* ClassPathXmlApplicationContext			-- 加载类路径下的Spring配置文件
			* FileSystemXmlApplicationContext			-- 加载本地磁盘下的Spring配置文件
	
	2. BeanFactory工厂（是Spring框架早期的创建Bean对象的工厂接口）
		* 使用BeanFactory接口也可以获取到Bean对象
			public void run(){
				BeanFactory factory = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));
				UserService us = (UserService) factory.getBean("us");
				us.sayHello();
			}
		
		* BeanFactory和ApplicationContext的区别
			* BeanFactory				-- BeanFactory采取延迟加载，第一次getBean时才会初始化Bean
			* ApplicationContext		-- 在加载applicationContext.xml时候就会创建具体的Bean对象的实例，还提供了一些其他的功能
				* 事件传递
				* Bean自动装配
				* 各种不同应用层的Context实现
	
----------
	
**入门总结之配置Spring框架编写XML的提示**
	
	1. 步骤一：先复制， http://www.springframework.org/schema/beans/spring-beans.xsd	
	2. 步骤二：搜索XML Catalog，点击Add按钮
	3. 步骤三：先选择Location的schema的约束地址
		* E:\class\2016\JavaEE28\day35_Spring框架第一天\资料\spring-framework-4.2.4.RELEASE-schema\beans\spring-beans-4.2.xsd
	4. 步骤四：注意：Key type要选择：Schema location
	5. 步骤五：Key把http://www.springframework.org/schema/beans/spring-beans.xsd复制上
	
----------
	
### 技术分析之Spring框架的Bean管理的配置文件方式 ###
	
----------
	
**技术分析之Spring框架中<bean>标签的配置**
	
	1. id属性和name属性的区别
		* id		-- Bean起个名字，在约束中采用ID的约束，唯一
			* 取值要求：必须以字母开始，可以使用字母、数字、连字符、下划线、句话、冒号	id:不能出现特殊字符
		
		* name		-- Bean起个名字，没有采用ID的约束（了解）
			* 取值要求：name:出现特殊字符.如果<bean>没有id的话 , name可以当做id使用
			* Spring框架在整合Struts1的框架的时候，Struts1的框架的访问路径是以/开头的，例如：/bookAction
	
	2. class属性			-- Bean对象的全路径
	3. scope属性			-- scope属性代表Bean的作用范围
		* singleton			-- 单例（默认值）
		* prototype			-- 多例，在Spring框架整合Struts2框架的时候，Action类也需要交给Spring做管理，配置把Action类配置成多例！！
		* request			-- 应用在Web项目中,每次HTTP请求都会创建一个新的Bean
		* session			-- 应用在Web项目中,同一个HTTP Session 共享一个Bean
		* globalsession		-- 应用在Web项目中,多服务器间的session
	
	4. Bean对象的创建和销毁的两个属性配置（了解）
		* 说明：Spring初始化bean或销毁bean时，有时需要作一些处理工作，因此spring可以在创建和拆卸bean的时候调用bean的两个生命周期方法
		* init-method		-- 当bean被载入到容器的时候调用init-method属性指定的方法
		* destroy-method	-- 当bean从容器中删除的时候调用destroy-method属性指定的方法
			* 想查看destroy-method的效果，有如下条件
				* scope= singleton有效
				* web容器中会自动调用，但是main函数或测试用例需要手动调用（需要使用ClassPathXmlApplicationContext的close()方法）
	
----------
	
**技术分析之依赖注入（DI）**
	
	1. IOC和DI的概念
		* IOC		-- Inverse of Control，控制反转，将对象的创建权反转给Spring！！
		* DI		-- Dependency Injection，依赖注入，在Spring框架负责创建Bean对象时，动态的将依赖对象注入到Bean组件中！！
	
	2.  DI（依赖注入）
		* 例如：如果UserServiceImpl的实现类中有一个属性，那么使用Spring框架的IOC功能时，可以通过依赖注入把该属性的值传入进来！！
		* 具体的配置如下
			<bean id="us" class="com.itheima.demo1.UserServiceImpl">
				<property name="uname" value="小风"/>
			</bean>
	
----------
	
**技术分析之Spring框架的属性注入**
	
	1. 对于类成员变量，常用的注入方式有两种
		* 构造函数注入
		* 属性set方法注入  推荐
	
	2. 在Spring框架中提供了前两种的属性注入的方式
		1. 构造方法的注入方式，两步
			* 编写Java的类，提供构造方法
				public class Car {
					private String name;
					private double money;
					public Car(String name, double money) {
						this.name = name;
						this.money = money;
					}
					@Override
					public String toString() {
						return "Car [name=" + name + ", money=" + money + "]";
					}
				}
			
			* 编写配置文件
				<bean id="car" class="com.itheima.demo4.Car">
					<constructor-arg name="name" value="大奔"/>
					<constructor-arg name="money" value="100"/>
				</bean>
		
		2. 属性的set方法的注入方式
			* 编写Java的类，提供属性和对应的set方法即可
			* 编写配置文件
		
		3. 如果Java类的属性是另一个Java的类，那么需要怎么来注入值呢？
			* <property name="name" rel="具体的Bean的ID或者name的值"/>
			* 例如：
				<bean id="person" class="com.itheima.demo4.Person">
					<property name="pname" value="美美"/>
					<property name="car2" ref="car2"/>
				</bean>
	
----------
	
**技术分析之Spring的2.5版本中提供了一种:p名称空间的注入（了解）**
	
	1. 步骤一：需要先引入 p 名称空间
		* 在schema的名称空间中加入该行：xmlns:p="http://www.springframework.org/schema/p"
	
	2. 步骤二：使用p名称空间的语法
		* p:属性名 = ""
		* p:属性名-ref = ""
	
	3. 步骤三：测试
		* <bean id="person" class="com.itheima.demo4.Person" p:pname="老王" p:car2-ref="car2"/>
	
----------
	
**技术分析之Spring的3.0提供了一种:SpEL注入方式（了解）**
	
	1. SpEL：Spring Expression Language是Spring的表达式语言，有一些自己的语法
	2. 语法
		* #{SpEL}
	
	3. 例如如下的代码
		<!-- SpEL的方式 -->
		<bean id="person" class="com.itheima.demo4.Person">
			<property name="pname" value="#{'小风'}"/>
			<property name="car2" value="#{car2}"/>
		</bean>
	
	4. 还支持调用类中的属性或者方法
		* 定义类和方法，例如
			public class CarInfo {
				public String getCarname(){
					return "奇瑞QQ";
				}
			}
	
----------
	
**技术分析之数组，集合(List,Set,Map)，Properties等的注入**
	
	1. 如果是数组或者List集合，注入配置文件的方式是一样的
		<bean id="collectionBean" class="com.itheima.demo5.CollectionBean">
			<property name="arrs">
				<list>
					<value>美美</value>
					<value>小风</value>
				</list>
			</property>
		</bean>
	
	2. 如果是Set集合，注入的配置文件方式如下：
		<property name="sets">
			<set>
				<value>哈哈</value>
				<value>呵呵</value>
			</set>
		</property>
	
	3. 如果是Map集合，注入的配置方式如下：
		<property name="map">
			<map>
				<entry key="老王2" value="38"/>
				<entry key="凤姐" value="38"/>
				<entry key="如花" value="29"/>
			</map>
		</property>
	
	4. 如果是properties属性文件的方式，注入的配置如下：
		<property name="pro">
			<props>
				<prop key="uname">root</prop>
				<prop key="pass">123</prop>
			</props>
		</property>
	
----------
	
**技术分析之Spring框架的配置文件分开管理（了解）**
	
	1. 例如：在src的目录下又多创建了一个配置文件，现在是两个核心的配置文件，那么加载这两个配置文件的方式有两种！
		* 主配置文件中包含其他的配置文件:
			<import resource="applicationContext2.xml"/>
		
		* 工厂创建的时候直接加载多个配置文件:
			ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
						"applicationContext.xml","applicationContext2.xml");
	
----------
	
### Spring框架整合WEB ###
	
----------
	
**Spring框架整合WEB（不是最终的方案）**
	
	1. 创建JavaWEB项目，引入Spring的开发包。编写具体的类和方法。
		* 环境搭建好后，启动服务器来测试项目，发送每访问一次都会加载一次配置文件，这样效率会非常非常慢！！
	
	2. 解决上面的问题
		* 将工厂创建好了以后放入到ServletContext域中.使用工厂的时候,从ServletContext中获得.
			* ServletContextListener:用来监听ServletContext对象的创建和销毁的监听器.
			* 当ServletContext对象创建的时候:创建工厂 , 将工厂存入到ServletContext
	
	3. Spring整合Web项目
		* 引入spring-web-4.2.4.RELEASE.jar包
		* 配置监听器
			 <!-- 配置Spring的核心监听器: -->
			 <listener>
			 	<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
			 </listener>
			 <context-param>
			 	<param-name>contextConfigLocation</param-name>
			 	<param-value>classpath:applicationContext.xml</param-value>
			 </context-param>
	
	4. 修改servlet的代码
		* 从ServletContext中获得工厂
		* 具体代码如下
			ServletContext servletContext = ServletActionContext.getServletContext();
			// 需要使用WEB的工厂的方式
			WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext);
			CustomerService cs = (CustomerService) context.getBean("customerService");
			cs.save();	
----------------------------------------------------------------------------------------------------------------------------------

  ## Spring框架第二天 ##

----------

**课程回顾：Spring框架第一天**
	
	1. 概述
		* IOC和AOP
	2. 框架的IOC的入门
		* 创建applicationContext.xml，引入约束，<bean/>	
		* 配置文件<bean id="" class="" name="" scope=""/>	
	3. 依赖注入
		* DI：依赖注入
	4. 整合WEB
		* Spring框架提供解决方案，先导入Spring-web.jar包，提供类
	
----------
	
**今天内容介绍**
	
	1. Spring框架的IOC基于注解的方式
	2. Spring框架整合JUnit单元测试
	3. AOP的概述
	4. AOP的底层实现原理（了解）
	5. AOP功能基于AspectJ的配置文件方式
	
----------
	
### 技术分析之Spring框架的IOC功能之注解的方式 ###
	
----------
	
**Spring框架的IOC之注解方式的快速入门**
	
	1. 步骤一：导入注解开发所有需要的jar包
		* 引入IOC容器必须的6个jar包
		* 多引入一个：Spring框架的AOP的jar包，spring-aop的jar包
	
	2. 步骤二：创建对应的包结构，编写Java的类
		* UserService			-- 接口
		* UserServiceImpl		-- 具体的实现类
	
	3. 步骤三：在src的目录下，创建applicationContext.xml的配置文件，然后引入约束。注意：因为现在想使用注解的方式，那么引入的约束发生了变化
		* 需要引入context的约束，具体的约束如下
			<beans xmlns="http://www.springframework.org/schema/beans"
			    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			    xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="
			        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
			        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"> <!-- bean definitions here -->
				
			</beans>
	
	4. 步骤四：在applicationContext.xml配置文件中开启组件扫描
		* Spring的注解开发:组件扫描
			<context:component-scan base-package="com.itheima.demo1"/>
			
		* 注意：可以采用如下配置
			<context:component-scan base-package="com.itheima"/> 这样是扫描com.itheima包下所有的内容
	
	5. 步骤五：在UserServiceImpl的实现类上添加注解
		* @Component(value="userService")	-- 相当于在XML的配置方式中 <bean id="userService" class="...">
	
	6. 步骤六：编写测试代码
		public class SpringDemo1 {
			@Test
			public void run1(){
				ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
				UserService us = (UserService) ac.getBean("userService");
				us.save();
			}
		}
	
----------
	
**Spring框架中Bean管理的常用注解**
	
	1. @Component:组件.(作用在类上)
	
	2. Spring中提供@Component的三个衍生注解:(功能目前来讲是一致的)
		* @Controller		-- 作用在WEB层
		* @Service			-- 作用在业务层
		* @Repository		-- 作用在持久层
		
		* 说明：这三个注解是为了让标注类本身的用途清晰，Spring在后续版本会对其增强
	
	3. 属性注入的注解(说明：使用注解注入的方式,可以不用提供set方法)
		* 如果是注入的普通类型，可以使用value注解
			* @Value			-- 用于注入普通类型
		
		* 如果注入的是对象类型，使用如下注解
			* @Autowired		-- 默认按类型进行自动装配
				* 如果想按名称注入
				* @Qualifier	-- 强制使用名称注入
		
		* @Resource		-- 相当于@Autowired和@Qualifier一起使用
			* 强调：Java提供的注解
			* 属性使用name属性
	
----------
	
**Bean的作用范围和生命周期的注解**
	
	1. Bean的作用范围注解
		* 注解为@Scope(value="prototype")，作用在类上。值如下：
			* singleton		-- 单例，默认值
			* prototype		-- 多例
	
	2. Bean的生命周期的配置（了解）
		* 注解如下：
			* @PostConstruct	-- 相当于init-method
			* @PreDestroy		-- 相当于destroy-method
	
----------
	
**Spring框架整合JUnit单元测试**
	
	1. 为了简化了JUnit的测试，使用Spring框架也可以整合测试
	2. 具体步骤
		* 要求：必须先有JUnit的环境（即已经导入了JUnit4的开发环境）！！
		
		* 步骤一：在程序中引入:spring-test.jar
		* 步骤二：在具体的测试类上添加注解
			@RunWith(SpringJUnit4ClassRunner.class)
			@ContextConfiguration("classpath:applicationContext.xml")
			public class SpringDemo1 {
				
				@Resource(name="userService")
				private UserService userService;
				
				@Test
				public void demo2(){
					userService.save();
				}
			}
	
----------
	
### 案例一：使用AOP技术对DAO层操作进行增强功能 ###
	
----------
	
**需求分析**
	
	1. 使用AOP技术对DAO层操作进行增强功能
	
----------
	
### 技术分析之Spring框架的核心功能之AOP技术 ###
	
----------
	
**AOP的概述**
	
	1. 什么是AOP的技术？
		* 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程
		* AOP是一种编程范式，隶属于软工范畴，指导开发者如何组织程序结构
		* AOP最早由AOP联盟的组织提出的,制定了一套规范.Spring将AOP思想引入到框架中,必须遵守AOP联盟的规范
		* 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术
		* AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型
		* 利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率
	
	2. AOP:面向切面编程.(思想.---解决OOP遇到一些问题)
	3. AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码（性能监视、事务管理、安全检查、缓存）
	
	4. 为什么要学习AOP
		* 可以在不修改源代码的前提下，对程序进行增强！！	
	
----------
	
**Spring框架的AOP的底层实现**
	
	1. Srping框架的AOP技术底层也是采用的代理技术，代理的方式提供了两种
		1. 基于JDK的动态代理
			* 必须是面向接口的，只有实现了具体接口的类才能生成代理对象
		
		2. 基于CGLIB动态代理
			* 对于没有实现了接口的类，也可以产生代理，产生这个类的子类的方式
	
	2. Spring的传统AOP中根据类是否实现接口，来采用不同的代理方式
		1. 如果实现类接口，使用JDK动态代理完成AOP
		2. 如果没有实现接口，采用CGLIB动态代理完成AOP
	
----------
	
**JDK的动态代理（代码了解，理解原理）**
	
	1. 使用Proxy类来生成代理对象的一些代码如下：
		/**
		 * 使用JDK的方式生成代理对象
		 * @author Administrator
		 */
		public class MyProxyUtils {
			public static UserDao getProxy(final UserDao dao) {
				// 使用Proxy类生成代理对象
				UserDao proxy = (UserDao) Proxy.newProxyInstance(dao.getClass().getClassLoader(),
						dao.getClass().getInterfaces(), new InvocationHandler() {
							
							// 代理对象方法一执行，invoke方法就会执行一次
							public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
								if("save".equals(method.getName())){
									System.out.println("记录日志...");
									// 开启事务
								}
								// 提交事务
								// 让dao类的save或者update方法正常的执行下去
								return method.invoke(dao, args);
							}
						});
				// 返回代理对象
				return proxy;
			}
		}
	
----------
	
**CGLIB的代理技术（代码了解）**
	
	1. 引入CBLIB的开发包
		* 如果想使用CGLIB的技术来生成代理对象，那么需要引入CGLIB的开发的jar包，在Spring框架核心包中已经引入了CGLIB的开发包了。所以直接引入Spring核心开发包即可！
	
	2. 编写相关的代码
		public static OrderDaoImpl getProxy(){
			// 创建CGLIB核心的类
			Enhancer enhancer = new Enhancer();
			// 设置父类
			enhancer.setSuperclass(OrderDaoImpl.class);
			// 设置回调函数
			enhancer.setCallback(new MethodInterceptor() {
				@Override
				public Object intercept(Object obj, Method method, Object[] args,
						MethodProxy methodProxy) throws Throwable {
					if("save".equals(method.getName())){
						// 记录日志
						System.out.println("记录日志了...");
					}
					return methodProxy.invokeSuper(obj, args);
				}
			});
			// 生成代理对象
			OrderDaoImpl proxy = (OrderDaoImpl) enhancer.create();
			return proxy;
		}
	
----------
	
### Spring基于AspectJ的AOP的开发 ###
	
----------
	
**技术分析之AOP的相关术语**
	
	1. Joinpoint(连接点)	-- 所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点
	2. Pointcut(切入点)		-- 所谓切入点是指我们要对哪些Joinpoint进行拦截的定义
	3. Advice(通知/增强)	-- 所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能)
	4. Introduction(引介)	-- 引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field
	5. Target(目标对象)		-- 代理的目标对象
	6. Weaving(织入)		-- 是指把增强应用到目标对象来创建新的代理对象的过程
	7. Proxy（代理）		-- 一个类被AOP织入增强后，就产生一个结果代理类
	8. Aspect(切面)			-- 是切入点和通知的结合，以后咱们自己来编写和配置的
	
----------
	
**技术分析之AspectJ的XML方式完成AOP的开发**
	
	1. 步骤一：创建JavaWEB项目，引入具体的开发的jar包
		* 先引入Spring框架开发的基本开发包
		* 再引入Spring框架的AOP的开发包
			* spring的传统AOP的开发的包
				* spring-aop-4.2.4.RELEASE.jar
				* com.springsource.org.aopalliance-1.0.0.jar
			
			* aspectJ的开发包
				* com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar
				* spring-aspects-4.2.4.RELEASE.jar
	
	2. 步骤二：创建Spring的配置文件，引入具体的AOP的schema约束
		<beans xmlns="http://www.springframework.org/schema/beans"
		       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		       xmlns:aop="http://www.springframework.org/schema/aop"
		       xsi:schemaLocation="
				http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
				http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">
		</beans>
	3. 步骤三：创建包结构，编写具体的接口和实现类
		* com.itheima.demo2
			* CustomerDao			-- 接口
			* CustomerDaoImpl		-- 实现类
	
	4. 步骤四：将目标类配置到Spring中
		<bean id="customerDao" class="com.itheima.demo3.CustomerDaoImpl"/>
	
	5. 步骤五：定义切面类
		public class MyAspectXml {
			// 定义通知
			public void log(){
				System.out.println("记录日志...");
			}
		}
	
	6. 步骤六：在配置文件中定义切面类
		<bean id="myAspectXml" class="com.itheima.demo3.MyAspectXml"/>
	
	7. 步骤七：在配置文件中完成aop的配置
		<aop:config>
			<!-- 引入切面类 -->
			<aop:aspect ref="myAspectXml">
				<!-- 定义通知类型：切面类的方法和切入点的表达式 -->
				<aop:before method="log" pointcut="execution(public * com.itheima.demo3.CustomerDaoImpl.save(..))"/>
			</aop:aspect>
		</aop:config>
	
	8. 完成测试
		@RunWith(SpringJUnit4ClassRunner.class)
		@ContextConfiguration("classpath:applicationContext.xml")
		public class Demo3 {
			@Resource(name="customerDao")
			private CustomerDao customerDao;
			@Test
			public void run1(){
				customerDao.save();
				customerDao.update();
				customerDao.delete();
			}
		}
	
----------
	
**切入点的表达式**
	
	1. 再配置切入点的时候，需要定义表达式，重点的格式如下：execution(public * *(..))，具体展开如下：
		* 切入点表达式的格式如下：
			* execution([修饰符] 返回值类型 包名.类名.方法名(参数))
		
		* 修饰符可以省略不写，不是必须要出现的。
		* 返回值类型是不能省略不写的，根据你的方法来编写返回值。可以使用 * 代替。
		* 包名例如：com.itheima.demo3.BookDaoImpl
			* 首先com是不能省略不写的，但是可以使用 * 代替
			* 中间的包名可以使用 * 号代替
			* 如果想省略中间的包名可以使用 .. 
		
		* 类名也可以使用 * 号代替，也有类似的写法：*DaoImpl
		* 方法也可以使用 * 号代替
		* 参数如果是一个参数可以使用 * 号代替，如果想代表任意参数使用 ..
	
----------
	
**AOP的通知类型**
	
	1. 前置通知
		* 在目标类的方法执行之前执行。
		* 配置文件信息：<aop:before method="before" pointcut-ref="myPointcut3"/>
		* 应用：可以对方法的参数来做校验
	
	2. 最终通知
		* 在目标类的方法执行之后执行，如果程序出现了异常，最终通知也会执行。
		* 在配置文件中编写具体的配置：<aop:after method="after" pointcut-ref="myPointcut3"/>
		* 应用：例如像释放资源
	
	3. 后置通知
		* 方法正常执行后的通知。		
		* 在配置文件中编写具体的配置：<aop:after-returning method="afterReturning" pointcut-ref="myPointcut2"/>
		* 应用：可以修改方法的返回值
	
	4. 异常抛出通知
		* 在抛出异常后通知
		* 在配置文件中编写具体的配置：<aop:after-throwing method="afterThorwing" pointcut-ref="myPointcut3"/>	
		* 应用：包装异常的信息
	
	5. 环绕通知
		* 方法的执行前后执行。
		* 在配置文件中编写具体的配置：<aop:around method="around" pointcut-ref="myPointcut2"/>
		* 要注意：目标的方法默认不执行，需要使用ProceedingJoinPoint对来让目标对象的方法执行。

	
----------------------------------------------------------------------------------------------------------------------------------

## Spring框架的第三天 ##
	
----------
	
**课程回顾：Spring框架第二天**
	
	1. IOC的注解方式
		* @Value
		* @Resource(name="")
	
	2. 整合JUnti单元测试
		* 先有Junit4运行环境
		* 导入spring-test.jar包
	
	3. Spring的AOP技术（XML的方式）	
		* 什么是AOP：面向切面编程
		* 采用代理技术完成（默认采用JDK接口方式，CGLIB技术代理对象）
		* AOP的入门
			* 编写切面类（编写通知的方法）
			* 配置AOP
			* 切入点的表达式（execution([public] * 包名.类名.方法(..))）
	
----------
	
**今天内容**
	
	1. Spring框架的AOP之注解的方式
	2. Spring框架的JDBC模板
	3. Spring框架的事务管理
	
----------
	
### 案例一：使用Spring框架的AOP技术对DAO层的功能进行增强 ###
	
----------
	
**案例一：使用Spring框架的AOP技术对DAO层的功能进行增强**
	
	1. 使用Spring框架的AOP技术对DAO层的功能进行增强
	
----------
	
**技术分析之：Spring框架的AOP技术（注解方式）**
	
	1. 步骤一：创建JavaWEB项目，引入具体的开发的jar包
		* 先引入Spring框架开发的基本开发包
		* 再引入Spring框架的AOP的开发包
			* spring的传统AOP的开发的包
				* spring-aop-4.2.4.RELEASE.jar
				* com.springsource.org.aopalliance-1.0.0.jar
			
			* aspectJ的开发包
				* com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar
				* spring-aspects-4.2.4.RELEASE.jar
	
	2. 步骤二：创建Spring的配置文件，引入具体的AOP的schema约束
		<beans xmlns="http://www.springframework.org/schema/beans"
		       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		       xmlns:aop="http://www.springframework.org/schema/aop"
		       xsi:schemaLocation="
				http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
				http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">
			
		</beans>
	
	3. 步骤三：创建包结构，编写具体的接口和实现类
		* com.itheima.demo1
			* CustomerDao			-- 接口
			* CustomerDaoImpl		-- 实现类
	
	4. 步骤四：将目标类配置到Spring中
		<bean id="customerDao" class="com.itheima.demo1.CustomerDaoImpl"/>
	
	5. 步骤五：定义切面类
		* 添加切面和通知的注解
			* @Aspect					-- 定义切面类的注解
			
			* 通知类型（注解的参数是切入点的表达式）
				* @Before				-- 前置通知
			    * @AfterReturing		-- 后置通知
			    * @Around				-- 环绕通知
			    * @After				-- 最终通知
			    * @AfterThrowing		-- 异常抛出通知
		
		* 具体的代码如下
			@Aspect
			public class MyAspectAnno {
				@Before(value="execution(public void com.itheima.demo1.CustomerDaoImpl.save())")
				public void log(){
					System.out.println("记录日志...");
				}
			}
	
	6. 步骤六：在配置文件中定义切面类
		<bean id="myAspectAnno" class="com.itheima.demo1.MyAspectAnno"/>
	
	7. 步骤七：在配置文件中开启自动代理
		<aop:aspectj-autoproxy/>
	
	8. 完成测试
		@RunWith(SpringJUnit4ClassRunner.class)
		@ContextConfiguration("classpath:applicationContext.xml")
		public class Demo1 {
			
			@Resource(name="customerDao")
			private CustomerDao customerDao;
			
			@Test
			public void run1(){
				customerDao.save();
				customerDao.update();
			}
		}
	
----------
	
**技术分析之通知类型**
	
	1. 通知类型
		* @Before				-- 前置通知
	    * @AfterReturing		-- 后置通知
	    * @Around				-- 环绕通知（目标对象方法默认不执行的，需要手动执行）
	    * @After				-- 最终通知
	    * @AfterThrowing		-- 异常抛出通知
	
	2. 配置通用的切入点
		* 使用@Pointcut定义通用的切入点
		
		@Aspect
		public class MyAspectAnno {
			@Before(value="MyAspectAnno.fn()")
			public void log(){
				System.out.println("记录日志...");
			}
			@Pointcut(value="execution(public void com.itheima.demo1.CustomerDaoImpl.save())")
			public void fn(){}
		}
	
----------
	
### 案例二：Spring框架的事务管理完成转账的案例 ###
	
----------

**需求分析**

	1. 完成一个转账的功能,需要进行事务的管理，使用Spring的事务管理的方式完成

----------

### Spring框架的JDBC模板技术 ###
	
----------
	
**技术分析之Spring框架的JDBC模板技术概述**

	1. Spring框架中提供了很多持久层的模板类来简化编程，使用模板类编写程序会变的简单
	2. 提供了JDBC模板，Spring框架提供的
		* JdbcTemplate类
	
	3. Spring框架可以整合Hibernate框架，也提供了模板类
		* HibernateTemplate类
	
----------
	
**技术分析之演示JDBC的模板类**
	
	1. 步骤一：创建数据库的表结构
		create database spring_day03;
		use spring_day03;
		create table t_account(
			id int primary key auto_increment,
			name varchar(20),
			money double
		);
	
	2. 引入开发的jar包
		* 先引入IOC基本的6个jar包
		* 再引入Spring-aop的jar包
		* 最后引入JDBC模板需要的jar包
			* MySQL数据库的驱动包
			* Spring-jdbc.jar
			* Spring-tx.jar
	
	3. 编写测试代码（自己来new对象的方式）
		@Test
		public void run1(){
			// 创建连接池，先使用Spring框架内置的连接池
			DriverManagerDataSource dataSource = new DriverManagerDataSource();
			dataSource.setDriverClassName("com.mysql.jdbc.Driver");
			dataSource.setUrl("jdbc:mysql:///spring_day03");
			dataSource.setUsername("root");
			dataSource.setPassword("root");
			// 创建模板类
			JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
			// 完成数据的添加
			jdbcTemplate.update("insert into t_account values (null,?,?)", "测试",10000);
		}
	
----------
	
**技术分析之使用Spring框架来管理模板类**
	
	1. 刚才编写的代码使用的是new的方式，应该把这些类交给Spring框架来管理。
	2. 修改的步骤如下
		* 步骤一：Spring管理内置的连接池
			<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		    	<property name="driverClassName" value="com.mysql.jdbc.Driver"/>
		    	<property name="url" value="jdbc:mysql:///spring_day03"/>
		    	<property name="username" value="root"/>
		    	<property name="password" value="root"/>
		    </bean>
		
		* 步骤二：Spring管理模板类
			<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
		    	<property name="dataSource" ref="dataSource"/>
		    </bean>
		
		* 步骤三：编写测试程序
			@RunWith(SpringJUnit4ClassRunner.class)
			@ContextConfiguration("classpath:applicationContext.xml")
			public class Demo2 {
				
				@Resource(name="jdbcTemplate")
				private JdbcTemplate jdbcTemplate;
				
				@Test
				public void run2(){
					jdbcTemplate.update("insert into t_account values (null,?,?)", "测试2",10000);
				}
			}
	
----------
	
**技术分析之Spring框架管理开源的连接池**
	
	1. 管理DBCP连接池
		* 先引入DBCP的2个jar包
			* com.springsource.org.apache.commons.dbcp-1.2.2.osgi.jar
			* com.springsource.org.apache.commons.pool-1.5.3.jar
		
		* 编写配置文件
			<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource">
		    	<property name="driverClassName" value="com.mysql.jdbc.Driver"/>
		    	<property name="url" value="jdbc:mysql:///spring_day03"/>
		    	<property name="username" value="root"/>
		    	<property name="password" value="root"/>
		    </bean>
	
	2. 管理C3P0连接池
		* 先引入C3P0的jar包
			* com.springsource.com.mchange.v2.c3p0-0.9.1.2.jar
		
		* 编写配置文件
			<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
		    	<property name="driverClass" value="com.mysql.jdbc.Driver"/>
		    	<property name="jdbcUrl" value="jdbc:mysql:///spring_day03"/>
		    	<property name="user" value="root"/>
		    	<property name="password" value="root"/>
		    </bean>
	
----------
	
**技术分析之Spring框架的JDBC模板的简单操作**
	
	1. 增删改查的操作
		@RunWith(SpringJUnit4ClassRunner.class)
		@ContextConfiguration("classpath:applicationContext.xml")
		public class SpringDemo3 {
			
			@Resource(name="jdbcTemplate")
			private JdbcTemplate jdbcTemplate;
			
			@Test
			// 插入操作
			public void demo1(){
				jdbcTemplate.update("insert into account values (null,?,?)", "冠希",10000d);
			}
			
			@Test
			// 修改操作
			public void demo2(){
				jdbcTemplate.update("update account set name=?,money =? where id = ?", "思雨",10000d,5);
			}
			
			@Test
			// 删除操作
			public void demo3(){
				jdbcTemplate.update("delete from account where id = ?", 5);
			}
			
			@Test
			// 查询一条记录
			public void demo4(){
				Account account = jdbcTemplate.queryForObject("select * from account where id = ?", new BeanMapper(), 1);
				System.out.println(account);
			}
			
			@Test
			// 查询所有记录
			public void demo5(){
				List<Account> list = jdbcTemplate.query("select * from t_account", new BeanMapper());
				for (Account account : list) {
					System.out.println(account);
				}
			}
		}
		
		class BeanMapper implements RowMapper<Account>{
			public Account mapRow(ResultSet rs, int arg1) throws SQLException {
				Account account = new Account();
				account.setId(rs.getInt("id"));
				account.setName(rs.getString("name"));
				account.setMoney(rs.getDouble("money"));
				return account;
			}
		}
	
----------
	
### 技术分析之Spring框架的事务管理 ###
	
----------
	
**技术分析之事务的回顾**
	
	1. 事务：指的是逻辑上一组操作，组成这个事务的各个执行单元，要么一起成功,要么一起失败！
	2. 事务的特性
		* 原子性
		* 一致性
		* 隔离性
		* 持久性
	
	3. 如果不考虑隔离性,引发安全性问题
		* 读问题:
			* 脏读:
			* 不可重复读:
			* 虚读:
		
		* 写问题:
			* 丢失更新:
	
	4. 如何解决安全性问题
		* 读问题解决，设置数据库隔离级别
		* 写问题解决可以使用 悲观锁和乐观锁的方式解决
	
----------
	
**技术分析之Spring框架的事务管理相关的类和API**
	
	1. PlatformTransactionManager接口		-- 平台事务管理器.(真正管理事务的类)。该接口有具体的实现类，根据不同的持久层框架，需要选择不同的实现类！
	2. TransactionDefinition接口			-- 事务定义信息.(事务的隔离级别,传播行为,超时,只读)
	3. TransactionStatus接口				-- 事务的状态
	
	4. 总结：上述对象之间的关系：平台事务管理器真正管理事务对象.根据事务定义的信息TransactionDefinition 进行事务管理，在管理事务中产生一些状态.将状态记录到TransactionStatus中
	
	5. PlatformTransactionManager接口中实现类和常用的方法
		1. 接口的实现类
			* 如果使用的Spring的JDBC模板或者MyBatis框架，需要选择DataSourceTransactionManager实现类
			* 如果使用的是Hibernate的框架，需要选择HibernateTransactionManager实现类
		
		2. 该接口的常用方法
			* void commit(TransactionStatus status) 
			* TransactionStatus getTransaction(TransactionDefinition definition) 
			* void rollback(TransactionStatus status) 
 	
	6. TransactionDefinition
		1. 事务隔离级别的常量
			* static int ISOLATION_DEFAULT 					-- 采用数据库的默认隔离级别
			* static int ISOLATION_READ_UNCOMMITTED 
			* static int ISOLATION_READ_COMMITTED 
			* static int ISOLATION_REPEATABLE_READ 
			* static int ISOLATION_SERIALIZABLE 
 		
		2. 事务的传播行为常量（不用设置，使用默认值）
			* 先解释什么是事务的传播行为：解决的是业务层之间的方法调用！！
			
			* PROPAGATION_REQUIRED（默认值）	-- A中有事务,使用A中的事务.如果没有，B就会开启一个新的事务,将A包含进来.(保证A,B在同一个事务中)，默认值！！
			* PROPAGATION_SUPPORTS			-- A中有事务,使用A中的事务.如果A中没有事务.那么B也不使用事务.
			* PROPAGATION_MANDATORY			-- A中有事务,使用A中的事务.如果A没有事务.抛出异常.
			
			* PROPAGATION_REQUIRES_NEW（记）-- A中有事务,将A中的事务挂起.B创建一个新的事务.(保证A,B没有在一个事务中)
			* PROPAGATION_NOT_SUPPORTED		-- A中有事务,将A中的事务挂起.
			* PROPAGATION_NEVER 			-- A中有事务,抛出异常.
			
			* PROPAGATION_NESTED（记）		-- 嵌套事务.当A执行之后,就会在这个位置设置一个保存点.如果B没有问题.执行通过.如果B出现异常,运行客户根据需求回滚(选择回滚到保存点或者是最初始状态)
	
----------
	
**技术分析之搭建事务管理转账案例的环境（强调：简化开发，以后DAO可以继承JdbcDaoSupport类）**
	
	1. 步骤一：创建WEB工程，引入需要的jar包
		* IOC的6个包
		* AOP的4个包
		* C3P0的1个包
		* MySQL的驱动包
		* JDBC目标2个包
		* 整合JUnit测试包
	
	2. 步骤二：引入配置文件
		* 引入配置文件
			* 引入log4j.properties
			
			* 引入applicationContext.xml
				<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
			    	<property name="driverClass" value="com.mysql.jdbc.Driver"/>
			    	<property name="jdbcUrl" value="jdbc:mysql:///spring_day03"/>
			    	<property name="user" value="root"/>
			    	<property name="password" value="root"/>
			    </bean>
	
	3. 步骤三：创建对应的包结构和类
		* com.itheima.demo1
			* AccountService
			* AccountServlceImpl
			* AccountDao
			* AccountDaoImpl
	
	4. 步骤四:引入Spring的配置文件,将类配置到Spring中
		<bean id="accountService" class="com.itheima.demo1.AccountServiceImpl">
		</bean>
		
		<bean id="accountDao" class="com.itheima.demo1.AccountDaoImpl">
		</bean>
	
	5. 步骤五：在业务层注入DAO ,在DAO中注入JDBC模板（强调：简化开发，以后DAO可以继承JdbcDaoSupport类）
		<bean id="accountService" class="com.itheima.demo1.AccountServiceImpl">
			<property name="accountDao" ref="accountDao"/>
		</bean>
		
		<bean id="accountDao" class="com.itheima.demo1.AccountDaoImpl">
			<property name="dataSource" ref="dataSource"/>
		</bean>
	
	6. 步骤六：编写DAO和Service中的方法
		public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao {
			public void outMoney(String out, double money) {
				this.getJdbcTemplate().update("update t_account set money = money = ? where name = ?", money,out);
			}
			public void inMoney(String in, double money) {
				this.getJdbcTemplate().update("update t_account set money = money + ? where name = ?", money,in);
			}
		}
	
	7. 步骤七：编写测试程序.
		@RunWith(SpringJUnit4ClassRunner.class)
		@ContextConfiguration("classpath:applicationContext.xml")
		public class Demo1 {
			
			@Resource(name="accountService")
			private AccountService accountService;
			
			@Test
			public void run1(){
				accountService.pay("冠希", "美美", 1000);
			}
		}
	
![](./图片/01-注入dataSource.bmp)
	
----------
	
**技术分析之Spring框架的事务管理的分类**
	
	1. Spring的事务管理的分类
		1. Spring的编程式事务管理（不推荐使用）
			* 通过手动编写代码的方式完成事务的管理（不推荐）
		
		2. Spring的声明式事务管理（底层采用AOP的技术）
			* 通过一段配置的方式完成事务的管理（重点掌握注解的方式）
	
----------
	
**技术分析之Spring框架的事务管理之编程式的事务管理（了解）**
	
	1. 说明：Spring为了简化事务管理的代码:提供了模板类 TransactionTemplate，所以手动编程的方式来管理事务，只需要使用该模板类即可！！
	
	2. 手动编程方式的具体步骤如下：
		1. 步骤一:配置一个事务管理器，Spring使用PlatformTransactionManager接口来管理事务，所以咱们需要使用到他的实现类！！
			<!-- 配置事务管理器 -->
			<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
				<property name="dataSource" ref="dataSource"/>
			</bean>
		
		2. 步骤二:配置事务管理的模板
			<!-- 配置事务管理的模板 -->
			<bean id="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate">
				<property name="transactionManager" ref="transactionManager"/>
			</bean>
		
		3. 步骤三:在需要进行事务管理的类中,注入事务管理的模板.
			<bean id="accountService" class="com.itheima.demo1.AccountServiceImpl">
				<property name="accountDao" ref="accountDao"/>
				<property name="transactionTemplate" ref="transactionTemplate"/>
			</bean>
		
		4. 步骤四:在业务层使用模板管理事务:
			// 注入事务模板对象
			private TransactionTemplate transactionTemplate;
			public void setTransactionTemplate(TransactionTemplate transactionTemplate) {
				this.transactionTemplate = transactionTemplate;
			}
			
			public void pay(final String out, final String in, final double money) {
				transactionTemplate.execute(new TransactionCallbackWithoutResult() {
					
					protected void doInTransactionWithoutResult(TransactionStatus status) {
						// 扣钱
						accountDao.outMoney(out, money);
						int a = 10/0;
						// 加钱
						accountDao.inMoney(in, money);
					}
				});
			}
	
![](./图片/02-注入过程.bmp)
	
----------
	 
**Spring框架的事务管理之声明式事务管理，即通过配置文件来完成事务管理(AOP思想)**
	
	1. 声明式事务管理又分成两种方式
		* 基于AspectJ的XML方式（重点掌握）
		* 基于AspectJ的注解方式（重点掌握）
	
----------
	
**Spring框架的事务管理之基于AspectJ的XML方式（重点掌握）**
	
	1. 步骤一:恢复转账开发环境
	
	2. 步骤二:引入AOP的开发包
	
	3. 步骤三:配置事务管理器
		<!-- 配置事务管理器 -->
		<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
			<property name="dataSource" ref="dataSource"/>
		</bean>
	
	4. 步骤四:配置事务增强
		<!-- 配置事务增强 -->
		<tx:advice id="txAdvice" transaction-manager="transactionManager">
			<tx:attributes>
				<!--
					name		：绑定事务的方法名，可以使用通配符，可以配置多个。
					propagation	：传播行为
					isolation	：隔离级别
					read-only	：是否只读
					timeout		：超时信息
					rollback-for：发生哪些异常回滚.
					no-rollback-for：发生哪些异常不回滚.
				 -->
				<!-- 哪些方法加事务 -->
				<tx:method name="pay" propagation="REQUIRED"/>
			</tx:attributes>
		</tx:advice>
	
	5. 步骤五:配置AOP的切面
		<!-- 配置AOP切面产生代理 -->
		<aop:config>
	    	<aop:advisor advice-ref="myAdvice" pointcut="execution(* com.itheima.demo2.AccountServiceImpl.pay(..))"/>
	    </aop:config>
		
		* 注意：如果是自己编写的切面，使用<aop:aspect>标签，如果是系统制作的，使用<aop:advisor>标签。
	
	6. 步骤六:编写测试类
		@RunWith(SpringJUnit4ClassRunner.class)
		@ContextConfiguration("classpath:applicationContext2.xml")
		public class Demo2 {
			
			@Resource(name="accountService")
			private AccountService accountService;
			
			@Test
			public void run1(){
				accountService.pay("冠希", "美美", 1000);
			}
		}
	
----------
	
**Spring框架的事务管理之基于AspectJ的注解方式（重点掌握，最简单的方式）**
	
	1. 步骤一:恢复转账的开发环境
	
	2. 步骤二:配置事务管理器
		<!-- 配置事务管理器  -->
		<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
			<property name="dataSource" ref="dataSource"/>
		</bean>
	
	3. 步骤三:开启注解事务
		<!-- 开启注解事务 -->
		<tx:annotation-driven transaction-manager="transactionManager"/>
	
	4. 步骤四:在业务层上添加一个注解:@Transactional
	
	5. 编写测试类
		@RunWith(SpringJUnit4ClassRunner.class)
		@ContextConfiguration("classpath:applicationContext3.xml")
		public class Demo3 {
			
			@Resource(name="accountService")
			private AccountService accountService;
			
			@Test
			public void run1(){
				accountService.pay("冠希", "美美", 1000);
			}
		}
	
----------

**Eclipse需要做设置**
	
	1. 统一工作空间的编码，选择UTF-8
	2. 把创建JSP页面的编码修改UTF-8
	3. 重新配置Tomcat服务器
		* 先配置Tomcat服务器
		* 选择服务器 --> open --> 选择发布项目的目录（webapps目录）
	
	4. SSH自己配置约束
	
----------------------------------------------------------------------------------------------------------------------------------

## Spring框架的第四天 ##

----------

**课程回顾：Spring框架第三天**
	
	1. AOP注解方式
		* 编写切面类（包含通知和切入点）
		* 开启自动代理
	
	2. JDBC模板技术
		* Spring提供模板技术，数据库的操作
		* 以后编写DAO层，都可以继承JdbcDaoSupport类（JDBC模板）
		* Spring框架可以整合开源连接池
	
	3. Spring事务管理
		* Spring框架事务管理需要接口和概述
			* PlatformTransactionManager接口（平台事务管理器接口），不管使用哪种方式管理事务，这个类必须配置的！！
		* 手动编码（了解）
		* 声明式事务管理方式（重点掌握），默认使用AOP的技术来增强
			* XML的方式
			* 注解的方式
	
----------
	
### 案例一：SSH框架整合保存客户 ###
	
----------
	
**需求分析**
	
	1. 案例一：SSH框架整合保存客户
	
----------
	
### 技术分析之SSH框架的整合 ###
	
----------
	
**技术分析之SSH框架开发的基本回顾**
	
![](./图片/01-SSH回顾.bmp)
	
----------
	
**技术分析之SSH三大框架需要的jar包**
	
	1. Struts2框架
		* struts-2.3.24\apps\struts2-blank\WEB-INF\lib\*.jar		-- Struts2需要的所有jar包
		* struts2-spring-plugin-2.3.24.jar							---Struts2整合Spring的插件包
	
	2. Hibernate框架
		* hibernate-release-5.0.7.Final\lib\required\*.jar			-- Hibernate框架需要的jar包
		* slf4j-api-1.6.1.jar										-- 日志接口
		* slf4j-log4j12-1.7.2.jar									-- 日志实现
		* mysql-connector-java-5.1.7-bin.jar						-- MySQL的驱动包
	
	3. Spring框架
		* IOC核心包
		* AOP核心包
		* JDBC模板和事务核心包
		* Spring整合JUnit测试包
		* Spring整合Hibernate核心包
		* Spring整合Struts2核心包
	
----------
	
**技术分析之SSH三大框架需要的配置文件**
	
	1. Struts2框架
		* 在web.xml中配置核心的过滤器
			<filter>
				<filter-name>struts2</filter-name>
				<filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>
			</filter>
			
			<filter-mapping>
				<filter-name>struts2</filter-name>
				<url-pattern>/*</url-pattern>
			</filter-mapping>
		
		* 在src目录下创建struts.xml，用来配置Action
	
	2. Hibernate框架
		* 在src目录创建hibernate.cfg.xml配置文件
		* 在JavaBean所在的包下映射的配置文件
	
	3. Spring框架
		* 在web.xml配置整合WEB的监听器
			<listener>
				<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
			</listener>
			<context-param>
				<param-name>contextConfigLocation</param-name>
				<param-value>classpath:applicationContext.xml</param-value>
			</context-param>
		
		* 在src目录下创建applicationContext.xml
		* 在src目录下log4j.proerties
	
----------
	
**技术分析之Spring框架整合Struts2框架**
	
	1. 导入CRM项目的UI页面，找到添加客户的页面，修改form表单，访问Action
	2. 编写CustomerAction接收请求，在struts.xml中完成Action的配置
		<package name="crm" extends="struts-default" namespace="/">
			<action name="customer_*" class="com.itheima.web.action.CustomerAction" method="{1}">
				
			</action>
		</package>
	
	3. 在Action中获取到service（开发不会使用，因为麻烦）
		* 可以通过 WebApplicationContextUtils.getWebApplicationContext(ServletActionContext.getServletContext()); 来获取，但是这种方式编写代码太麻烦了！！
	
	4. Spring整合Struts2框架的第一种方式（Action由Struts2框架来创建）
		* 因为导入的struts2-spring-plugin-2.3.24.jar 包自带一个配置文件 struts-plugin.xml ，该配置文件中有如下代码
			* <constant name="struts.objectFactory" value="spring" />	开启一个常量，如果该常量开启，那么下面的常量就可以使用
			* struts.objectFactory.spring.autoWire = name，该常量是可以让Action的类来自动装配Bean对象！！
	
	5. Spring整合Struts2框架的第二种方式（Action由Spring框架来创建）（推荐大家来使用的）
		* 把具体的Action类配置文件applicatonContext.xml的配置文件中，但是注意：struts.xml需要做修改
		* applicationContext.xml
			* <bean id="customerAction" class="com.itheima.web.action.CustomerAction" scope="prototype">
		
		* struts.xml中的修改，把全路径修改成ID值
			* <action name="customer_*" class="customerAction" method="{1}">
		
		* 第二种方式需要有两个注意的地方
			* Spring框架默认生成CustomerAction是单例的，而Struts2框架是多例的。所以需要配置 scope="prototype"
			* CustomerService现在必须自己手动注入了
	
----------
	
**技术分析之Spring框架整合Hibernate框架（带有hibernate.cfg.xml的配置文件。强调：不能加绑定当前线程的配置）**

	1. 编写CustomerDaoImpl的代码，加入配置并且在CustomerServiceImpl中完成注入
	2. 编写映射的配置文件，并且在hibernate.cfg.xml的配置文件中引入映射的配置文件
	
	3. 在applicationContext.xml的配置文件，配置加载hibernate.cfg.xml的配置
		<bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
			<property name="configLocation" value="classpath:hibernate.cfg.xml"/>
		</bean>
	
	4. 在CustomerDaoImpl中想完成数据的添加，Spring框架提供了一个HibernateDaoSupport的工具类，以后DAO都可以继承该类！！
		public class CustomerDaoImpl extends HibernateDaoSupport implements CustomerDao {
			public void save(Customer c) {
				System.out.println("持久层...");
				this.getHibernateTemplate().save(c);
			}
		}
		
		<bean id="customerDao" class="com.itheima.dao.CustomerDaoImpl">
			<property name="sessionFactory" ref="sessionFactory"/>
		</bean>
	
	5. 开启事务的配置
		* 先配置事务管理器，注意现在使用的是Hibernate框架，所以需要使用Hibernate框架的事务管理器
			<bean id="transactionManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager">
				<property name="sessionFactory" ref="sessionFactory"/>
			</bean>
		
		* 开启注解事务
			<tx:annotation-driven transaction-manager="transactionManager"/>
		
		* 在Service类中添加事务注解
			@Transactional
	
----------
	
**技术分析之Spring框架整合Hibernate框架（不带有hibernate.cfg.xml的配置文件）**
	
	1. Hibernate配置文件中
		* 数据库连接基本参数（4大参数）
		* Hibernate相关的属性
		* 连接池
		* 映射文件
	
	2. 开始进行配置
		* 先配置连接池相关的信息
			<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
				<property name="driverClass" value="com.mysql.jdbc.Driver"/>
				<property name="jdbcUrl" value="jdbc:mysql:///xxx"/>
				<property name="user" value="root"/>
				<property name="password" value="root"/>
			</bean>
		
		* 修改 LocalSessionFactoryBean 的属性配置，因为已经没有了hibernate.cfg.xml的配置文件，所以需要修改该配置，注入连接池
			<bean id="transactionManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager">
				<property name="dataSource" ref="dataSource"/>
			</bean>
		
		* 继续在 LocalSessionFactoryBean 中配置，使用hibernateProperties属性继续来配置其他的属性，注意值是properties属性文件
			<!-- 配置其他的属性 -->
			<property name="hibernateProperties">
				<props>
					<prop key="hibernate.dialect">org.hibernate.dialect.MySQLDialect</prop>
					<prop key="hibernate.show_sql">true</prop>
					<prop key="hibernate.format_sql">true</prop>
					<prop key="hibernate.hbm2ddl.auto">update</prop>
				</props>
			</property>
			<!-- 配置映射 -->
			<property name="mappingResources">
				<list>
					<value>com/itheima/domain/Customer.hbm.xml</value>
				</list>
			</property>
	
----------
	
**技术分析之Hibernate的模板的常用的方法**
	
	1. 增删改的操作:
		* 添加:
			* save(Object obj);
		* 修改:
			* update(Object obj);
		* 删除:
			* delete(Object obj);
	
	2. 查询的操作:
		* 查询一条记录:
			* Object get(Class c,Serializable id);
			* Object load(Class c,Serializable id);
	
	3. 查询多条记录:
		* List find(String hql,Object... args);
	
----------
	
**技术分析之延迟加载问题**
	
	1. 使用延迟加载的时候，再WEB层查询对象的时候程序会抛出异常！
		* 原因是延迟加载还没有发生SQL语句，在业务层session对象就已经销毁了，所以查询到的JavaBean对象已经变成了托管态对象！
		
		* 注意：一定要先删除javassist-3.11.0.GA.jar包（jar包冲突了）
	
	2. 解决办法非常简单，Spring框架提供了一个过滤器，让session对象在WEB层就创建，在WEB层销毁。只需要配置该过滤器即可
		* 但是：要注意需要在struts2的核心过滤器之前进行配置
			<filter>
				<filter-name>OpenSessionInViewFilter</filter-name>
				<filter-class>org.springframework.orm.hibernate5.support.OpenSessionInViewFilter</filter-class>
			</filter>
			<filter-mapping>
				<filter-name>OpenSessionInViewFilter</filter-name>
				<url-pattern>/*</url-pattern>
			</filter-mapping>
	

